import java.io.*;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ScannerBuffer;
import java_cup.runtime.XMLElement;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.*;
import javax.xml.transform.stream.*;
import java.util.*;
import java.lang.*;

parser code {:

	public Parser(Lexer lex, ComplexSymbolFactory sf){
		super(lex,sf);
	}

	public static void main(String[] args) throws Exception{

		ComplexSymbolFactory csf = new ComplexSymbolFactory();
		Reader rscanner;
		rscanner = new BufferedReader(new FileReader("source.txt"));
		ScannerBuffer lexer = new ScannerBuffer(new Lexer(rscanner,csf));

		Parser p = new Parser(lexer,csf);
		XMLElement e = (XMLElement)p.parse().value;

		XMLOutputFactory outFactory = XMLOutputFactory.newInstance();
		XMLStreamWriter sw = outFactory.createXMLStreamWriter(new FileOutputStream("outStream.xml"));
		XMLElement.dump(lexer,sw,e,"expr","stmt");

		Transformer transformer = TransformerFactory.newInstance().newTransformer(new StreamSource(new File("tree.xsl")));

		Source text = new StreamSource(new File("outStream.xml"));
		transformer.transform(text, new StreamResult(new File("output.xml")));
		transformer = TransformerFactory.newInstance().newTransformer(new StreamSource(new File("tree-view.xsl")));

		text = new StreamSource(new File("output.xml"));
		transformer.transform(text, new StreamResult(new File("ast.html")));

	}
:}

// Terminales
terminal            SUMSUBS,MULDIV,LPAR,RPAR,SEMICOLON,COMMA,DOTDOT,ABORT,AND,CASE,DIGITS,EXCEPTION,GOTO,LOOP,OF,RECORD,SELECT,THEN,WITH,ABS,ARRAY,CONSTANT,DO,EXIT,IF,MOD,OR,PRIVATE,REM,SEPARATE,TYPE,XOR,ACCEPT,AT,DECLARE,ELSE,FOR,IN,NEW,OTHERS,PROCEDURE,RENAMES,SUBTYPE,USE,ACCESS,BEGIN,DELAY,END,FUNCTION,IS,NOT,OUT,RAISE,RETURN,TASK,WHEN,ALL,BODY,DELTA,ENTRY,GENERIC,LIMITED,NULL,ELSIF,PACKAGE,RANGE,REVERSE,TERMINATE,WHILE,BOOLEAN,GET,PUT,IDEN,OPREL,ASSIGN,INTEGER,FLOAT;
terminal Integer    NUM;      
terminal Double     REAL;

//No terminales
non terminal           procedure,sequence_of_statements,empty,arithmetic_expression,term,factor,statement,relation,
					   boolean_operation,expression,assignment_statement,simple_statement,compound_statement,
					   if_statement,condition,elsif,else,loop_statement,while_or_for,rest_of_loop,condition_part,initial;

//Precedencias
precedence left MULDIV;
precedence left SUMSUBS;

//Gramaticas

initial ::= procedure;

procedure ::= PROCEDURE IDEN IS BEGIN procedure END IDEN SEMICOLON 
			| PROCEDURE IDEN IS BEGIN sequence_of_statements procedure END IDEN SEMICOLON 
			| empty;

sequence_of_statements ::= sequence_of_statements statement 
		| statement;

statement ::= simple_statement | compound_statement;

simple_statement ::= assignment_statement;

compound_statement ::= if_statement | loop_statement;

if_statement ::= IF condition_part elsif else END IF SEMICOLON
                |error;

elsif ::= elsif ELSIF condition_part
		|empty;

condition_part ::= condition THEN sequence_of_statements;

else ::=  ELSE sequence_of_statements
		| empty;

loop_statement ::= while_or_for;

while_or_for ::= WHILE condition rest_of_loop;

rest_of_loop ::= LOOP sequence_of_statements END LOOP SEMICOLON;

condition ::= expression;

assignment_statement ::= IDEN ASSIGN expression SEMICOLON;

expression ::= expression boolean_operation relation
			| relation;

boolean_operation ::= AND|OR|XOR;

relation ::= arithmetic_expression OPREL arithmetic_expression
			|arithmetic_expression; 

arithmetic_expression ::= arithmetic_expression SUMSUBS term
			|term;

term ::= term MULDIV factor
		|factor;

factor ::=  IDEN
		  | NUM
		  | REAL
		  | LPAR arithmetic_expression RPAR;

empty ::= /* nothing */;