import java.io.*;
import java_cup.runtime.ComplexSymbolFactory;
import java_cup.runtime.ScannerBuffer;
import java_cup.runtime.Symbol;
import java_cup.runtime.XMLElement;
import javax.xml.stream.XMLOutputFactory;
import javax.xml.stream.XMLStreamWriter;
import javax.xml.transform.*;
import javax.xml.transform.stream.*;
import java.util.*;
import java.lang.*;

parser code {:
	
        int err = 0;
	public void syntax_error (Symbol s)
	{
            err++;
            int line = s.right;
            int column = s.left;
            System.out.println("Syntax error near line " + line + ", column " + column + "; found: " + s.value + ".");
	}

	public void unrecovered_syntax_error (Symbol s) throws java.lang.Exception
	{
            err++;
            System.out.println("Could not recover from error.");
	}
        
    public void PrintErrores()
    {
        System.out.println( err +" errors were found.");
    }

    public void report_error(String message, Object info) {
    if (info instanceof String){
	err++; 
      System.err.println("  "+ err + "==> " + info + " "+ message+".");
    }
    else {
    	StringBuffer m = new StringBuffer("Error ");
    	if (info instanceof java_cup.runtime.Symbol) 
     	   m.append( "("+info.toString()+")" );     
    	m.append(" : "+message);   
    	System.err.println(m);
     }
   }

	public Parser(Lexer lex, ComplexSymbolFactory sf){
		super(lex,sf);
	}

	public static void main(String[] args) throws Exception{

		ComplexSymbolFactory csf = new ComplexSymbolFactory();
		Reader rscanner;
		rscanner = new BufferedReader(new FileReader("source.txt"));
		ScannerBuffer lexer = new ScannerBuffer(new Lexer(rscanner,csf));

		Parser p = new Parser(lexer,csf);
		XMLElement e = (XMLElement)p.parse().value;

		XMLOutputFactory outFactory = XMLOutputFactory.newInstance();
		XMLStreamWriter sw = outFactory.createXMLStreamWriter(new FileOutputStream("outStream.xml"),"UTF-8");
		XMLElement.dump(lexer,sw,e,"expr","stmt");

		Transformer transformer = TransformerFactory.newInstance().newTransformer(new StreamSource(new File("tree.xsl")));

		Source text = new StreamSource(new File("outStream.xml"));
		transformer.transform(text, new StreamResult(new File("output.xml")));
		transformer = TransformerFactory.newInstance().newTransformer(new StreamSource(new File("tree-view.xsl")));

		text = new StreamSource(new File("output.xml"));
		transformer.transform(text, new StreamResult(new File("ast.html")));

	}
:}

// Terminales
terminal            SUMSUBS,MULDIV,LPAR,RPAR,SEMICOLON,COMMA,DOTDOT,ABORT,AND,CASE,DIGITS,EXCEPTION,GOTO,LOOP,OF,RECORD,SELECT,THEN,WITH,ABS,ARRAY,CONSTANT,DO,EXIT,IF,MOD,OR,PRIVATE,REM,SEPARATE,TYPE,XOR,ACCEPT,AT,DECLARE,ELSE,FOR,IN,NEW,OTHERS,PROCEDURE,RENAMES,SUBTYPE,USE,ACCESS,BEGIN,DELAY,END,FUNCTION,IS,NOT,OUT,RAISE,RETURN,TASK,WHEN,ALL,BODY,DELTA,ENTRY,GENERIC,LIMITED,NULL,ELSIF,PACKAGE,RANGE,REVERSE,TERMINATE,WHILE,BOOLEAN,GET,PUT,IDEN,OPREL,ASSIGN,INTEGER,FLOAT;
terminal Integer    NUM;      
terminal Double     REAL;

//No terminales
non terminal           procedure,sequence_of_statements,empty,arithmetic_expression,term,factor,statement,relation,
					   boolean_operator,expression,assignment_statement,simple_statement,compound_statement,
					   if_statement,condition,elsif,else,loop_statement,while_or_for,rest_of_loop,condition_part;

//Precedencias
precedence left MULDIV;
precedence left SUMSUBS;

//Gramaticas

procedure ::= PROCEDURE IDEN IS BEGIN procedure END IDEN SEMICOLON 
			| PROCEDURE IDEN IS BEGIN sequence_of_statements procedure END IDEN SEMICOLON 
			| empty;

sequence_of_statements ::= sequence_of_statements statement 
		| statement;

statement ::= simple_statement | compound_statement;

simple_statement ::= assignment_statement;

compound_statement ::= if_statement | loop_statement;

if_statement ::= IF condition_part elsif else END IF SEMICOLON
                | error {: parser.report_error("if_statement","WRONG"); :}
                ;

elsif ::= elsif ELSIF condition_part
		| empty;

condition_part ::= condition THEN sequence_of_statements;

else ::=  ELSE sequence_of_statements
		| empty;

loop_statement ::= while_or_for;

while_or_for ::= WHILE condition rest_of_loop;

rest_of_loop ::= LOOP sequence_of_statements END LOOP SEMICOLON;

condition ::= expression;

assignment_statement ::= IDEN ASSIGN expression SEMICOLON
			| IDEN ASSIGN error SEMICOLON {: parser.report_error("assignment_statement","WRONG"); :}
			;

expression ::= expression boolean_operator relation
			| relation;

boolean_operator ::= AND|OR|XOR;

relation ::= arithmetic_expression OPREL arithmetic_expression
			|arithmetic_expression
			|arithmetic_expression error arithmetic_expression {: parser.report_error("relation, expected OPREL","WRONG"); :}
			; 

arithmetic_expression ::= arithmetic_expression SUMSUBS term
			|term;

term ::= term MULDIV factor
		|factor
		;

factor ::=  IDEN
		  | NUM
		  | REAL
		  | LPAR arithmetic_expression RPAR
		  ;

empty ::= /* nothing */;